export const meta = {
  title: 'Quantum Fundamentals: Single and Multiple Qubit Systems',
  date: '2025-10-08',
  tags: ['quantum computing', 'physics', 'qiskit', 'research', 'seminar'],
  excerpt:
    'A comprehensive exploration of quantum computing fundamentals, covering complex numbers, Hilbert spaces, superposition, entanglement, and practical implementations with Qiskit.',
  readingTime: 25,
  featured: true,
};

# Quantum Fundamentals: Single and Multiple Qubit Systems

_Quantum Seminar - September 25, 2025_  
_Presenter: Nguyen Minh Tri_

---

## Introduction

Welcome to this comprehensive exploration of quantum computing fundamentals! In this seminar, we dive deep into the mathematical foundations and practical applications of single and multiple qubit systems. Whether you're new to quantum computing or looking to solidify your understanding, this guide will take you through the essential concepts with clear explanations and interactive examples.

---

## ğŸ”¢ Complex Numbers: The Foundation of Quantum Computing

### Why Must It Be Complex Numbers?

One of the first questions in quantum computing is: **Why do we need complex numbers?** The answer lies in the wave-like nature of quantum systems.

#### The Qubit State & The Necessity of Complex Numbers

> **Premise**: Quantum states have wave-like properties. As established, quantum systems behave like waves. A key property of any wave is its **phase**. Therefore, our mathematical description of a quantum state must be able to account for this phase.

The most general way to write the state of a single qubit, |ÏˆâŸ©, is:

```
|ÏˆâŸ© = cos(Î¸/2)|0âŸ© + e^(iÏ†)sin(Î¸/2)|1âŸ©
```

Where:

- The real parts control the **probability balance** between |0âŸ© and |1âŸ©
- The term e^(iÏ†) is the crucial **relative phase factor**

#### Why Complex Numbers are Essential

The phase factor is defined by Euler's formula, which is inherently complex:

```
e^(iÏ†) = cos(Ï†) + i sin(Ï†)
```

**Conclusion**: To fully describe a qubit's state, we must include its relative phase (e^(iÏ†)). Since this phase factor is fundamentally a complex number (containing i), the entire framework for describing quantum states **must use complex numbers**.

---

## ğŸŒŒ Hilbert Space of Multi-Qubit Systems

### Combining Hilbert Spaces: The Tensor Product

How do we mathematically describe a two-qubit system? We combine their spaces using the **tensor product** (âŠ—).

#### Rule: Forming the New Basis

The basis for the combined system is formed by the tensor product of **every** basis vector from each individual space.

- Qubit A basis: {`|0âŸ©_A`, `|1âŸ©_A`}
- Qubit B basis: {`|0âŸ©_B`, `|1âŸ©_B`}

The new 4D basis for the combined system is:

```
{`|00âŸ©`, `|01âŸ©`, `|10âŸ©`, `|11âŸ©`}
```

#### Tensor Product: Vector Representation

The tensor product of column vectors is the **Kronecker product**:

```
|01âŸ© = |0âŸ© âŠ— |1âŸ© = [1] âŠ— [0] = [0]
                      [0]   [1]   [1]
                                  [0]
                                  [0]
```

This is why the Hilbert space dimensions multiply: 2 Ã— 2 = 4.

---

## âš¡ Core Concepts Revisited

### Superposition: The Fundamental Rule

#### The "Rule of the Game"

The principle of superposition is a direct consequence of the linearity of the SchrÃ¶dinger equation in Hilbert space.

- **Core Idea**: If a system can be in state |AâŸ© and also in state |BâŸ©, then any linear combination |ÏˆâŸ© = Î±|AâŸ© + Î²|BâŸ© is also a valid state.
- **Wave Analogy**: Multiple individual waves adding up to form a single composite wave, allowing for interference.

![Superposition visualization](/assets/quantum/Superposition.png)
_Figure: Combination of 2 wave functions_

**For a Qubit**: This is why a qubit's state can be |ÏˆâŸ© = Î±|0âŸ© + Î²|1âŸ©.

### Entanglement: The Essence

#### What is an Entangled State?

An entangled state is a shared state for a multi-part system that **cannot be separated** into individual states for its components.

- **Separable State**: |01âŸ© = |0âŸ© âŠ— |1âŸ© (We can describe each qubit individually)
- **Entangled State**: (1/âˆš2)(|00âŸ© + |11âŸ©) (The state of one qubit is undefined without the other)

#### Entanglement vs. Our Classical Worldview

For centuries, physics was built on two intuitive assumptions:

1. **Realism**: Objects have definite, pre-existing properties, independent of observation.
   _(A hidden coin is already heads or tails; we just don't know which.)_

2. **Locality**: An object is only influenced by its immediate surroundings. No influence can travel faster than light.
   _(Flipping a coin here cannot instantly flip a coin on the Moon.)_

> **The "Spooky" Challenge**: Entanglement seems to violate this. Measuring one particle appears to instantly determine the state of its distant partner.

#### The Verdict: Bell's Theorem

In 1964, John Bell devised a mathematical test. He proved that if local realism were true, the correlations between entangled particles would have a strict limit.

**Experiments have decisively and repeatedly shown that this limit is violated.**

**Conclusion**: The universe does **not** obey Local Realism. We must abandon at least one of our core classical assumptions about reality.

[Learn more about Bell's Inequality](https://www.youtube.com/watch?v=9OM0jSTeeBg)

#### Making Sense of It: The Many-Worlds Interpretation

One possible "story" to explain the strangeness of entanglement:

- **Core Idea**: The wave function is real and never collapses. Instead, the universe **branches** for each possible measurement outcome.
- **How it explains entanglement**:
  - When you measure your entangled qubit, the universe splits
  - In one branch, you get 0 and your distant partner also gets 0
  - In another branch, another "you" gets 1 and your partner gets 1
  - The perfect correlation is preserved across corresponding branches
  - The "spooky action" is the branching of reality itself

---

## ğŸ›ï¸ Qubit Mathematics & Single-Qubit Gates

### Single-Qubit Gates: Unitary Operations

Gates are 2Ã—2 unitary matrices acting on qubit state: |Ïˆ'âŸ© = U|ÏˆâŸ©, with Uâ€ U = I.

#### Pauli Gates

**Pauli-X (NOT/bit-flip)**:

```
X = [0 1]
    [1 0]
```

Flips |0âŸ© to |1âŸ© and |1âŸ© to |0âŸ©.

**Pauli-Z (phase flip)**:

```
Z = [1  0]
    [0 -1]
```

Leaves |0âŸ© unchanged, flips phase of |1âŸ© to -|1âŸ©.

**Pauli-Y (bit + phase flip)**:

```
Y = [0 -i]
    [i  0]
```

Combines effects of X and Z.

#### Hadamard (H) Gate

**Superposition Creator**:

```
H = (1/âˆš2) [1  1]
           [1 -1]
```

Examples:

- H|0âŸ© = (1/âˆš2)(|0âŸ© + |1âŸ©) = |+âŸ© (equal probabilities for 0 and 1)
- H|1âŸ© = (1/âˆš2)(|0âŸ© - |1âŸ©) = |-âŸ©

#### Phase Gates

**General Phase Gate (P_Î¸)**:

```
P_Î¸ = [1    0   ]
      [0  e^(iÎ¸)]
```

**S Gate**: A specific phase gate where Î¸ = Ï€/2

```
S = [1  0]
    [0  i]
```

**T Gate**: A specific phase gate where Î¸ = Ï€/4

```
T = [1       0      ]
    [0  (1+i)/âˆš2]
```

### Rotation Gates: Why We Need Them

#### Continuous Control

Unlike Pauli gates (fixed 0/1 flips or 90/180-degree phase shifts), rotation gates allow **continuous control** over the qubit's state. They're essential for fine-tuning quantum states and implementing algorithms that require parameter optimization.

> **Visualization**: All single-qubit rotations can be visualized as rotating the state vector on the **Bloch Sphere**.
>
> [Interactive Bloch Sphere Visualizer](https://bloch.kherb.io/)

#### Rotation Gates: X, Y, and Z Rotations

**Rotation around X-axis (RX(Î¸))**:

```
R_x(Î¸) = [cos(Î¸/2)   -i sin(Î¸/2)]
         [-i sin(Î¸/2)  cos(Î¸/2) ]
```

**Rotation around Y-axis (RY(Î¸))**:

```
R_y(Î¸) = [cos(Î¸/2)  -sin(Î¸/2)]
         [sin(Î¸/2)   cos(Î¸/2)]
```

**Rotation around Z-axis (RZ(Î¸))**:

```
R_z(Î¸) = [e^(-iÎ¸/2)     0     ]
         [    0      e^(iÎ¸/2) ]
```

### Single-Qubit Calculations: Matrix Multiplication

**Goal**: Apply X, then H on |0âŸ©, compute via matrices.

**Step 1 (X Gate)**:

```
X|0âŸ© = [0 1] [1] = [0] = |1âŸ©
       [1 0] [0]   [1]
```

**Step 2 (H Gate)**:

```
H|1âŸ© = (1/âˆš2) [1  1] [0] = (1/âˆš2) [1 ] = (|0âŸ© - |1âŸ©)/âˆš2 = |-âŸ©
              [1 -1] [1]          [-1]
```

**Combined Operation**:

```
U = H Â· X = (1/âˆš2) [1  1] [0 1] = (1/âˆš2) [1  1]
                   [1 -1] [1 0]          [-1 1]
```

**Final State**:

```
U|0âŸ© = (1/âˆš2) [1  1] [1] = (1/âˆš2) [1 ] = |-âŸ©
              [-1 1] [0]          [-1]
```

---

## ğŸ”— Two-Qubit Systems

### Two-Qubit Systems: State Space

#### Why Multi-Qubits?

- **Single qubit**: 2D Hilbert space (|ÏˆâŸ© = Î±|0âŸ© + Î²|1âŸ©)
- **Two qubits**: 4D Hilbert space via tensor product, which enables entanglement

#### Tensor Product (âŠ—): Combines Individual State Spaces

Example: |0âŸ© âŠ— |0âŸ© = |00âŸ© = [1, 0, 0, 0]áµ€

#### General State

A superposition of all 4 basis states:

```
|Î¨âŸ© = a|00âŸ© + b|01âŸ© + c|10âŸ© + d|11âŸ©
```

With normalization: |a|Â² + |b|Â² + |c|Â² + |d|Â² = 1

### Multi-Qubit Gates

#### Example: Apply H on the First Qubit

To apply a Hadamard gate to the first qubit while leaving the second unchanged (I), we use the tensor product of the gate matrices: H âŠ— I.

```
H âŠ— I = (1/âˆš2) [1 0 1 0]
               [0 1 0 1]
               [1 0 -1 0]
               [0 1 0 -1]
```

Applying this to the state |00âŸ©:

```
(H âŠ— I)|00âŸ© = (|00âŸ© + |10âŸ©)/âˆš2
```

This creates a superposition between the two qubits.

### Example Calculation On Circuit

![Sample Circuit](/assets/quantum/Sample_circuit.png)
_Figure: Two-Qubit Circuit with Multiple Gates_

![Circuit Clarification](/assets/quantum/circuit_clarify.png)
_Figure: Clarified Circuit with Gate Labels_

#### Circuit Operations

- Qubit 0: H â†’ Z
- Qubit 1: X â†’ H â†’ R_X(Ï€/2) â†’ Z
- CNOT between qubits

**Initial**: |Ïˆâ‚€âŸ© = |00âŸ©

The complete calculation involves:

1. **Step 1**: Apply H âŠ— X
2. **Step 2**: Apply CNOT gate
3. **Step 3**: Apply I âŠ— H
4. **Step 4**: Apply I âŠ— R_X(Ï€/2)
5. **Step 5**: Apply Z âŠ— Z

**Final State**:

```
|Ïˆ_finalâŸ© = (Z âŠ— Z) Â· (I âŠ— R_X(Ï€/2)) Â· (I âŠ— H) Â· CNOT Â· (H âŠ— X) Â· |00âŸ©
```

The final state is a complex superposition of all four basis states with the form:

```
|Ïˆ_finalâŸ© = câ‚€|00âŸ© + câ‚|01âŸ© + câ‚‚|10âŸ© + câ‚ƒ|11âŸ©
```

where |câ‚€|Â² + |câ‚|Â² + |câ‚‚|Â² + |câ‚ƒ|Â² = 1.

---

## ğŸ’» Interactive Qiskit Examples

Throughout this seminar, we explored practical implementations using Qiskit. Here are some key code snippets:

### Basic Quantum State Visualization

```python
import numpy as np
import matplotlib.pyplot as plt
from qiskit import QuantumCircuit
from qiskit.visualization import plot_bloch_multivector
from qiskit.quantum_info import Statevector

# Create superposition state
state = np.array([1/np.sqrt(2), 1/np.sqrt(2)])  # (|0âŸ© + |1âŸ©)/âˆš2
prob = np.abs(state)**2

plt.bar([0, 1], prob)
plt.xticks([0, 1], ['|0âŸ©', '|1âŸ©'])
plt.ylabel('Probability')
plt.title('Quantum State Probability Distribution')
plt.show()
```

### Single-Qubit Circuit Examples

```python
# Hadamard followed by X gate
qc = QuantumCircuit(1)
qc.h(0)  # Hadamard gate
qc.x(0)  # Pauli-X gate

# Get the final state
state = Statevector.from_instruction(qc)
print(state)  # [0.707+0j, -0.707+0j]

# Visualize on Bloch sphere
plot_bloch_multivector(state)
```

### Two-Qubit Entanglement Circuit

```python
# Create the circuit from our example
qc = QuantumCircuit(2)
qc.h(0)     # Hadamard on qubit 0
qc.x(1)     # X gate on qubit 1
qc.cx(0, 1) # CNOT gate
qc.h(1)     # Hadamard on qubit 1
qc.rx(np.pi/2, 1)  # RX(Ï€/2) rotation on qubit 1
qc.z(0)     # Z gate on qubit 0
qc.z(1)     # Z gate on qubit 1

# Get final state and visualize
state = Statevector.from_instruction(qc)
plot_bloch_multivector(state)
qc.draw('mpl')
```

---

## ğŸ¯ Conclusion

In this comprehensive seminar, we've explored the fundamental concepts that make quantum computing possible:

- **Complex Numbers**: Essential for describing quantum phases and the wave-like nature of quantum states
- **Hilbert Space**: The mathematical framework that allows us to combine quantum systems using tensor products
- **Superposition**: The principle that enables quantum systems to exist in multiple states simultaneously
- **Entanglement**: The "spooky" quantum phenomenon that challenges our classical understanding of reality

These concepts form the foundation for understanding more advanced quantum algorithms and applications. The unique capabilities of quantum computingâ€”from quantum parallelism to quantum interferenceâ€”all stem from these fundamental principles.

As we continue to develop quantum technologies, these mathematical foundations will remain crucial for designing quantum algorithms, optimizing quantum circuits, and ultimately harnessing the full power of quantum computation.

---

## ï¿½ Download Resources

Want to dive deeper? Download the original presentation materials:

- **[ğŸ“„ PDF Presentation](/assets/quantum/Seminar_Quantum_25092025.pdf)** - Complete slide deck
- **[ğŸ’» Jupyter Notebook](/assets/quantum/W2_Basics_with_Qiskit.ipynb)** - Interactive code examples
- **[ğŸ–¼ï¸ Figures & Diagrams](/assets/quantum/)** - All presentation figures

## ï¿½ğŸ“š Additional Resources

- [Qiskit Textbook](https://qiskit.org/textbook/)
- [Interactive Bloch Sphere](https://bloch.kherb.io/)
- [Bell's Inequality Explained](https://www.youtube.com/watch?v=9OM0jSTeeBg)
- [Quantum Computing: An Applied Approach](https://www.springer.com/gp/book/9783030239213)

---

_This seminar material is part of the ongoing quantum computing education series. For more advanced topics and hands-on exercises, please refer to the accompanying Jupyter notebook and additional resources._
